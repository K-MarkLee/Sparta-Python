# 비트연산자

# 비트 AND
bit = 5 & 3
# 5는 101이고 3은 11이기 때문에 and는 똑같이 1인 값을 찾음. 101과 11의 공통은 1이다
# 정답은 01로 1


# 비트 OR
bit = 5 | 3
# or은 모든 1을 찾음. 5는 101, 3은 11이기떄문에 111이 나온다. 비교시 11 또는 10 또는 01 일시 1을 배출
# 정답은 111로 7


# 비트 XOR
bit = 5 ^ 3
# xor은 비교시 1 1 을 제외한 10 과 01 을 1로 표시. 5는 101, 3은 11이니 늘리자면 101 과 011의 xor 이다. 이때 110이 되므로
# 정답은 110인 6


# 비트 NOT
bit = ~5
# not은 비트를 반전 시키는 연산자 이다. 이때 5를 2진수로 표현한다면, 101이지만 앞에 0000 0101이렇게 0들이 숨어있다. 숫자 앞의 0000은 부호비트이며
# 이 부호비트가 0 일때는 양수 1일때는 음수이다. not은 반전을 시키니 1111 1010이렇게 된다. 이를 2진수로 변환하려면 2의 보수를 사용.
# 2의 보수는 반전을 시킴과 동시에 +1을 하여야 한다. 그러므로 1111 1010을 반전 시키면 0000 0101 에 +1을 하게되면 0000 0110이 된다. 
# 정답은 음수인 0110 즉 -6


# 음수의 not연산자 
bit = ~-5
# 5의 음수는 바로 2의 보수로 변환해야하니. 0000 0101 은 2의 보수로 인하여 1111 1011이 된다. not의 연산자로 반전이 되니
# 0000 0100이 되므로
# 정답은 양수인 0100 즉 4


# 왼쪽 시프트 <<
bit = 5 << 1
# 5의 2진수는 101이다 이를 1칸 <방향으로 옮기는것 이다. 그렇게 되면 0101은 1010이 되므로 즉 10이 된다.
# 만약 5 << 2 는 0101을 2칸 옮기는 것으로 10100이 되므로 20이 된다.
# 정답은 1010인 10


# 오른쪽 시프트 >>
bit = 5 >> 1
# 정답은 010인 2


# 연산자 in/not in 이는 변수 안에 할당된 값이 리스트 처럼 되어있을때, 정확하게 그 값을 찾는것.

# 연산자 is/is not 은 객체가 같은가 확인하는 것이다. 만약 x,y의 데이터가 정확하게 같다고 할때, x=z라고 추가로 해둔다.
# 이렇게 될때 x is z 는 x = z이기 때문에 true값이 나온다.
# x is y는 x와 y의 할당된 값이 같지만, 객체인 x와 y는 다른 존재임으로 false값이 나온다.
# 이때 x == y는 값이 똑같으므로 true이다.


print(bit)

